# bulk-prepare_calc_CpG_PDR.R - this script takes the output files generated by bulk-bam2epiallele.R
# ans splits them by chromosome to allow for downstream pipeline analyses to be processed in parallel

require(optparse)
require(genomation)
require(GenomicRanges)


# Input arguments
option_list <- list(
  make_option(c("-i","--indir"), action="store", default=NULL, type="character",
              help="Directory containing epimutation output files for one sample."),
  make_option(c("-o","--outdir"), action="store", default=NULL, type="character",
              help="Output directory.")
  )

args <- parse_args(OptionParser(option_list=option_list))
indir <- args$indir
outdir <- args$outdir


##### Input arguments #####
# Identify the methylation status, loci, and CpG site depth files
status_file <- list.files(path = indir, pattern = "_epiallele_CpG_status.txt", full.names = TRUE)
loci_file <- list.files(path = indir, pattern = "_epiallele_CpG_loci.bed", full.names = TRUE)
cpg_depth_file <- list.files(path = indir, pattern = "_epiallele_CpG_site_depth.txt", full.names = TRUE)
###########################


# Load sample data
eCpG_status <- read.delim(status_file, header = FALSE)
eCpG_loci <- readBed(loci_file)
eCpG_depth <- read.delim(cpg_depth_file,header = FALSE)

# Extract methylation calls from eCpG_status
eCpG_status.calls <- eCpG_status[, seq(3, ncol(eCpG_status)-1, 2)]

# Sum methylation calls across reads in order to calculate concordant and discordant reads
eCpG_status.eSum <- rowSums(eCpG_status.calls, na.rm = TRUE)

# Extract CpG positions from eCpG_status
eCpG_status.start_chr <- eCpG_status[,1]
eCpG_status.loci <- eCpG_status[, seq(2, ncol(eCpG_status)-1, 2)]

eCpG_status.siteID <- apply(eCpG_status.loci,2,function(x) paste0(eCpG_status.start_chr,"_",x))

# Create subdirectory for temporary output files
if (!dir.exists(paste0(outdir,"/","CpG_PDR"))) {dir.create(paste0(outdir,"/","CpG_PDR"))}
subdir <- paste0(outdir,"/","CpG_PDR")

### Split eCpG_depth, eCpG_status.eSum, eCpG_status.calls, eCpG_status.siteID by chromosome
# Identify the existing chromosmes
chrs <- unlist(lapply(strsplit(as.character(eCpG_depth$V1),"_"),'[',1))
# Loop through each chromosome to identify corresponding files
for (i in 1:length(unique(chrs))) {
  # Extract data overlapping given chromosome
  temp.eCpG_depth <- eCpG_depth[which(unlist(lapply(strsplit(as.character(eCpG_depth$V1),"_"),'[',1)) == unique(chrs)[i]),]
  temp.eCpG_status.eSum <- eCpG_status.eSum[which(eCpG_status.start_chr == as.integer(unique(chrs)[i]))]
  temp.eCpG_status.calls <- eCpG_status.calls[which(eCpG_status.start_chr == as.integer(unique(chrs)[i])),]
  temp.eCpG_status.siteID <- eCpG_status.siteID[which(eCpG_status.start_chr == as.integer(unique(chrs)[i])),]
  
  # Write subsetted data to file
  write.table(temp.eCpG_depth, file = paste0(subdir,"/",basename(indir),"_eCpG_depth-chr",i,".txt"),
              quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  write.table(as.data.frame(temp.eCpG_status.eSum), file = paste0(subdir,"/",basename(indir),"_eCpG_status.eSum-chr",i,".txt"),
              quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  write.table(as.data.frame(temp.eCpG_status.calls), file = paste0(subdir,"/",basename(indir),"_eCpG_status.calls-chr",i,".txt"),
              quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  write.table(as.data.frame(temp.eCpG_status.siteID), file = paste0(subdir,"/",basename(indir),"_eCpG_status.siteID-chr",i,".txt"),
              quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
}

