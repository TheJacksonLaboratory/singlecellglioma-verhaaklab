# bulk-bam2epiallele.R - identifies concordant and discordant reads from an input BAM file generated by Bismark

# BAM file columns: 
# (1) QNAME (seq-ID)
# (2) FLAG (this flag tries to take the strand a bisulfite read originated from into account (this is different from ordinary DNA alignment flags!))
# (3) RNAME (chromosome)
# (4) POS (start position)
# (5) MAPQ (calculated for Bowtie 2 and HISAT2)
# (6) CIGAR
# (7) RNEXT
# (8) PNEXT
# (9) TLEN
# (10) SEQ
# (11) QUAL (Phred33 scale)
# (12) NM-tag (edit distance to the reference)
# (13) MD-tag (base-by-base mismatches to the reference) 
# (14) XM-tag (methylation call string)
# (15) XR-tag (read conversion state for the alignment) 
# (16) XG-tag (genome conversion state for the alignment)

require(optparse)
require(stringr)
require(data.table)
require(tictoc)
# library(future.apply)
# plan(multiprocess, workers = 8)

# Input arguments
option_list <- list(
  make_option(c("-b","--bam"), action="store", default=NULL, type="character",
              help="Input coordinate-sorted bam file, in text format (.txt).
              Generated using samtools view without the -b argument flag."),
  make_option(c("-l","--loci"), action="store", default=NULL, type="character",
              help="Bed file containing loci of CpGs passing target coverage threshold.
              Generated using process_RRBS.R."),
  make_option(c("-c","--count"), action="store", default=4, type="integer",
              help="Minimum number of CpGs required in a read for it to be analyzed."),
  make_option(c("-o","--outdir"), action="store", default=NULL, type="character",
              help="Output directory.")
  )

args <- parse_args(OptionParser(option_list=option_list))
bam <- args$bam
loci <- args$loci
count <- args$count
outdir <- args$outdir


# Load bam file
reads <- read.delim(bam, header = FALSE, stringsAsFactors = FALSE)
names(reads) <- c("QNAME","FLAG","RNAME","POS","MAPQ","CIGAR","RNEXT","PNEXT","TLEN","SEQ","QUAL","NM-tag","MD-tag","XM-tag","XR-tag","XG-tag")

# Remove reads not aligned to autosomal chromosomes
reads <- reads[which(reads$RNAME %in% c(1:22)),]
# Record total number of reads considered for analysis
totReads <- dim(reads)[1]

# Extract methylation calls from reads
calls <- lapply(strsplit(reads$`XM-tag`,":"), `[`, 3)

# Discard reads with less than "count" CpGs
totCs <- str_count(calls,"Z") + str_count(calls,"z")
lowCcalls <- which(totCs < count)
reads.discard <- reads[lowCcalls,]

reads.filtered <- reads[-lowCcalls,]

# Partition filtered reads into all methylated, all unmethylated, and mixed
reads.filtered.all_meth <- reads.filtered[which(str_count(calls,"Z")[-lowCcalls] == (str_count(calls,"Z")[-lowCcalls] + str_count(calls,"z")[-lowCcalls])),]

reads.filtered.all_unmeth <- reads.filtered[which(str_count(calls,"z")[-lowCcalls] == (str_count(calls,"Z")[-lowCcalls] + str_count(calls,"z")[-lowCcalls])),]

reads.filtered.mixed_meth <- reads.filtered[which(str_count(calls,"Z")[-lowCcalls] > 0 & str_count(calls,"z")[-lowCcalls] > 0),]


# Check read grouping
# meth_calls <- lapply(strsplit(reads.filtered.all_meth$`XM-tag`,":"), `[`, 3)
# meth_check <- data.frame(Z=str_count(meth_calls,"Z"), z=str_count(meth_calls,"z"))
# 
# unmeth_calls <- lapply(strsplit(reads.filtered.all_unmeth$`XM-tag`,":"), `[`, 3)
# unmeth_check <- data.frame(Z=str_count(unmeth_calls,"Z"), z=str_count(unmeth_calls,"z"))
# 
# mixed_calls <- lapply(strsplit(reads.filtered.mixed_meth$`XM-tag`,":"), `[`, 3)
# mixed_check <- data.frame(Z=str_count(mixed_calls,"Z"), z=str_count(mixed_calls,"z"))


### Identify, per grouping, the position and average methylation of the first "count" CpGs in a read
calls.filtered <- calls[-lowCcalls]

# # Remove unused objects to free space
# rm(list = c("calls","reads"))


### Record position and methylation calls for CpGs of non-discarded reads
# Methylation call sequences; Z = methylated C in CpG context; z = unmethylated C in CpG context
call_sequence <- lapply(calls.filtered, function(x) unlist(strsplit(x,""))) 
call_sequence.chr <- as.integer(reads.filtered$RNAME)
call_sequence.start <- reads.filtered$POS

# Extract indices of CpGs in each call_sequence
zs <- lapply(call_sequence, function(x) which(x %in% c("z","Z"))) 
# Convert output to matrix format
zs.matrix <- matrix(nrow = length(zs), ncol = max(unlist(lapply(zs,length))))
for (i in 1:length(zs)) {
  zs.matrix[i,c(1:length(zs[[i]]))] <- zs[[i]]
}

# Convert indices to CpG start position
zs.pos <- zs.matrix + call_sequence.start - 1

# Create CpG ID for each eCpG consisting of chr_start.pos
zs.posID <- apply(zs.pos,2,function(x) paste(call_sequence.chr,x,sep = "_"))

### Filter CpGs to those with 10x coverage in sample 
### NOTE: Assuming coverage was previously evaluated using process_RRBS.R
# Load BED file of CpGs passing coverage threshold as a data frame
high_cov_CpGs <- read.delim(loci, header = FALSE)
names(high_cov_CpGs) <- c("chr","start","end","name","score","strand")

# Convert start position from 0-based to 1-based
high_cov_CpGs$start <- high_cov_CpGs$start + 1

# Create CpG ID for each high coverage CpG consisting of chr_start.pos
high_cov_CpGID <- paste0(high_cov_CpGs$chr,"_",high_cov_CpGs$start)

# Extract indices of CpGs in call matrix
zs_ind <- which(!zs.posID %in% "1_NA")

# Extract indices of high coverage CpGs
high_cov_zs <- which(zs.posID %in% high_cov_CpGID)

# Initiazlize binary matrix with the same dimesnsions as zs.posID, 
# and set indices with high coverage CpGs to 1
binary <- matrix(0,nrow = nrow(zs.posID), ncol = ncol(zs.posID))
binary[high_cov_zs] <- 1

# Sum each row in binary matrix to determine the number of high coverage CpGs per read
binary_rowSums <- rowSums(binary)

# Calculate the number of CpGs in each call_sequence
zs_per_read <- unlist(lapply(zs,length))

# Identify high coverage reads as those where the number of CpGs with high coverage
# equals the calculated number of CpGs in the call sequence
high_cov_reads <- as.integer(rownames(plyr::match_df(data.frame(numCpGs=binary_rowSums),data.frame(numCpGs=zs_per_read))))

# For reference, write indices of high coverage reads to file
write.table(high_cov_reads, paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_high_coverage_epiallele_ind.txt"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")

# For reference write to file the number of reads before and after filtering on CpG coverage
write.table(data.frame(sample=strsplit(basename(bam),".txt")[[1]], epiallele_count=length(calls.filtered), filtered_epiallele_count=length(high_cov_reads)), 
            paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_high_coverage_epiallele_count.txt"), row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")

# Filter methylation call files to identified reads
zs <- zs[high_cov_reads]
zs.matrix <- zs.matrix[high_cov_reads,]
zs.pos <- zs.pos[high_cov_reads,]
zs.posID <- zs.posID[high_cov_reads,]
call_sequence <- call_sequence[high_cov_reads]
call_sequence.chr <- call_sequence.chr[high_cov_reads]
call_sequence.start <- call_sequence.start[high_cov_reads]

# Recalculate all methylated, all unmethylated, and mixed reads
reads.filtered.all_meth <- reads.filtered[which(str_count(calls,"Z")[-lowCcalls][high_cov_reads] == (str_count(calls,"Z")[-lowCcalls][high_cov_reads] + str_count(calls,"z")[-lowCcalls][high_cov_reads])),]

reads.filtered.all_unmeth <- reads.filtered[which(str_count(calls,"z")[-lowCcalls][high_cov_reads] == (str_count(calls,"Z")[-lowCcalls][high_cov_reads] + str_count(calls,"z")[-lowCcalls][high_cov_reads])),]

reads.filtered.mixed_meth <- reads.filtered[which(str_count(calls,"Z")[-lowCcalls][high_cov_reads] > 0 & str_count(calls,"z")[-lowCcalls][high_cov_reads] > 0),]
###

# Condense zs.posID matrix to a vector
zs.posID <- matrix(zs.posID, ncol = 1, byrow = TRUE)
if (any(grep("NA",zs.posID))) {zs.posID <- zs.posID[-grep("NA",zs.posID)]}

# Calculate distance between first and last CpG in a given epiallele
num_call_zs <- unlist(lapply(zs,length))
zs.dist <- vector(mode = "integer", length = length(num_call_zs))
for (i in 1:length(num_call_zs)) {zs.dist[i] <- zs.pos[i,num_call_zs[i]] - zs.pos[i,1]}

# Record start and stop positions of the first and last CpG for each epiallele
call_sequence.loci_end <- vector(mode = "integer", length = length(num_call_zs))
for (i in 1:length(num_call_zs)) {call_sequence.loci_end[i] <- as.integer(zs.pos[i,num_call_zs[i]] + 1)}
call_sequence.loci <- data.frame(chr=paste0("chr",call_sequence.chr),start=as.integer(zs.pos[,1] - 1),end=call_sequence.loci_end)

# Record methylation status of epiallele CpGs
zs.call <- matrix(nrow = nrow(zs.matrix), ncol = ncol(zs.matrix))
for (i in 1:nrow(zs.matrix)) {
  zs.call[i,c(1:num_call_zs[i])] <- as.integer(sapply(call_sequence[[i]][zs.matrix[i,c(1:num_call_zs[i])]], switch, Z=1, z=0))
}

# Combine methylation position and status outputs into one table
rows.combined <- nrow(zs.pos) 
cols.combined <- ncol(zs.pos) + ncol(zs.call)
call_sequence.output <- matrix(nrow=rows.combined, ncol=cols.combined)
call_sequence.output[, seq(1, cols.combined, 2)] <- zs.pos
call_sequence.output[, seq(2, cols.combined, 2)] <- zs.call
call_sequence.output <- data.frame(call_sequence.chr,call_sequence.output,zs.dist)
call_sequence.output <- as.data.frame(call_sequence.output)
names(call_sequence.output) <- unlist(str_split(c("Chr",paste(paste0("C",seq(1,max(num_call_zs)),"_pos"), paste0("C",seq(1,max(num_call_zs)),"_status"), sep = " "),"Dist"), " "))


# Save eCpG position and methylation status to file
write.table(call_sequence.output, paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_epiallele_CpG_status-unsorted.txt"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")

# Save epiallele location to file
write.table(call_sequence.loci, paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_epiallele_CpG_loci-unsorted.bed"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")

# Save list of eCpGs to file
write.table(zs.posID, paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_epiallele_CpG_siteID-unsorted.txt"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")

# Generate histogram of depth of coverage for CpGs in epialleles
zs.posID <- data.frame(zs.posID)
names(zs.posID) <- "id"
eCpGs <- data.table(zs.posID)
eCpG_count <- eCpGs[, .(rowCount = .N), by = id]

# Save histogram table to file
write.table(eCpG_count, paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_epiallele_CpG_site_depth-unsorted.txt"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")

# Save histogram figure to file
pdf(paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_epiallele_CpG_site_depth.pdf"), width = 12, height = 9, useDingbats = FALSE, title='')
hist(eCpG_count$rowCount, main = strsplit(basename(bam),".txt")[[1]], xlab = "Epiallele CpG site depth")
dev.off()

# Generate PDR output table 
readProportion <- data.frame(Sample=strsplit(basename(bam),".txt")[[1]],
                             Total_Reads=totReads,
                             All_Meth_Reads=dim(reads.filtered.all_meth)[1],
                             All_Meth_Pct=signif((dim(reads.filtered.all_meth)[1]/totReads)*100,4),
                             Mixed_Meth_Reads=dim(reads.filtered.mixed_meth)[1],
                             Mixed_Meth_Pct=signif((dim(reads.filtered.mixed_meth)[1]/totReads)*100,4),
                             All_Unmeth_Reads=dim(reads.filtered.all_unmeth)[1],
                             All_Unmeth_Pct=signif((dim(reads.filtered.all_unmeth)[1]/totReads)*100,4),
                             Discarded_Reads=length(which(!seq(1,length(calls.filtered)) %in% high_cov_reads)) + length(lowCcalls),
                             Discarded_Pct=signif(((length(which(!seq(1,length(calls.filtered)) %in% high_cov_reads)) + length(lowCcalls))/totReads)*100,4),
                             Unique_CpGs=dim(eCpG_count)[1]
)
write.table(readProportion, file = paste0(outdir,"/",strsplit(basename(bam),".txt")[[1]],"_read_distribution.txt"), row.names = FALSE, col.names = FALSE, quote = FALSE, sep = "\t")
